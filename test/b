#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-

require "bundler/setup"
require "screw"
require "thread"
require_relative "thread"

class Pool

  def initialize(jobs)
    @busy = []
    @send = []
    @idle = []
    @jobs = (1..jobs).to_a
    @lock = Mutex.new
  end

  def once
    @lock.synchronize do
      if @jobs.size == 0
        Screw.logger.info "Pool done."
        raise Interrupt
      else
        if @idle.size == 0
          # Screw.logger.debug "No idle workers, waiting"
        else
          job    = @jobs.pop
          worker = @idle.pop
          @send << worker
          worker.async.perform job
          # Screw.logger.info "Pool sent job to worker; job:#{job}."
        end
      end
    end
  end

  def run
    loop do
      begin
        once
      rescue Interrupt, SignalException => x
        Screw.logger.error "yield failed due to: #{x.inspect}; stopping; pool:#{self}"
        break
      rescue Exception => x
        Screw.logger.error "yield failed due to: #{x.class.name} #{x.inspect}; continuing; pool:#{self}"
      end
    end
    stop_all
  end

  def ready(worker)
    @lock.synchronize do
      @busy.delete(worker)
      @send.delete(worker)
      @idle << worker
      # Screw.logger.info "Pool has #{@idle.size} idle workers."
    end
  end

  def working(worker)
    @lock.synchronize do
      @idle.delete(worker)
      @send.delete(worker)
      @busy << worker
    end
  end

  def stop_all
    [ @idle, @busy, @send ].each { |s| s.each { |i| i.stop! } }
  end

  def to_s
    "Pool(busy:#{@busy.size},send:#{@send.size},idle:#{@idle.size},jobs:#{@jobs.size})"
  end
end

Thread.current[:name] = "main"
pool = Pool.new(4)

2.times do
  pool.ready Screw::Worker.new(pool)
end

Screw.logger.debug "main running; current=#{Thread.current.inspect}"
pool.run
Screw.logger.info "main done."
